<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BGC: Finding reachable memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BGC<span id="projectnumber">&#160;v0.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Finding reachable memory </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The hallmark of a conservative garbage collector is that it does not collect any memory unless it determines that it is no longer <em>reachable</em>. In order for any allocation to be reachable, there needs to be a pointer in the working memory of the program that points to said allocation. The working memory is the BSS (we ignore that on purpose), the CPU registers (we dump those on the stack before scanning), the stack and all existing (<code>gc</code>-managed) allocations on the heap.</p>
<p >Scanning means that we test each of these memory locations for a pointer to another memory location, determining the transitive closure of allocated memory. Everything that is not in the transitive closure is then collected.</p>
<p >Note that there are many ways how each of these steps can be optimized but most of these optimizations are platfrom/compiler-dependent and therefore out of the scope of <code>gc</code> (at least currently).</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Memory layout of a C program</h1>
<p >In order to understand the scanning process, it is necessary to understand the standard memory layout of a C program:</p>
<p ><img src="mem_layout.png" alt="" align="center" width="350" class="inline"/></p>
<p >The key observations for our discussion are</p>
<ol type="1">
<li>The stack grows towards <em>smaller</em> memory addresses. This is the case for all mainstream platforms, either by convention or by requirement.</li>
<li>The heap grows upwards</li>
</ol>
<p >There are platforms on which the stack grows towards larger memory addresses but we're safe to ignore those for the scope of <code>gc</code>.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Scanning the stack</h1>
<p >Scanning the stack starts by determining the stack boundaries. The <em>bottom-of-stack</em> pointer, named <code>stack_bp</code> refers to the <em>address of the lowest stack frame on the stack</em> (i.e. the highest address in memory). The <em>top-of-stack</em> pointer referes to the highest stack frame on the stack, i.e. the <em>lowest</em> address on the stack. In other words, we expect <code>stack_sp</code> &lt; <code>stack_bp</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> bgc_mark_stack(GarbageCollector* gc)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> dummy;</div>
<div class="line">    <span class="keywordtype">void</span> *stack_sp = (<span class="keywordtype">void</span>*) &amp;dummy;</div>
<div class="line">    <span class="keywordtype">void</span> *stack_bp = gc-&gt;stack_bp;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">char</span>* p = (<span class="keywordtype">char</span>*) stack_sp; p &lt;= (<span class="keywordtype">char</span>*) stack_bp - BGC_PTRSIZE; ++p) {</div>
<div class="line">        bgc_mark_alloc(gc, *(<span class="keywordtype">void</span>**)p);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >The code here is straightforward:</p>
<ol type="1">
<li>Declare a local variable <code>dummy</code> on the stack such that we can use its address as top-of -stack, ie. <code>stack_sp = &amp;dummy</code>.</li>
<li>Get the bottom-of-stack from the <code>gc</code> instance.</li>
<li>Iterate over all memory locations between <code>stack_sp</code> and <code>stack_bp</code> and check if they contain references to known memory locations (<code>gc_mark_alloc()</code> queries the allocation map and recursively marks the allocations if the pointed-to memory allocations are a known key in the allocation map). We do not iterate all the way to <code>stack_bp</code> since the last <code>BGC_PTRSIZE-1</code> bytes are too short to hold valid pointer addresses.</li>
</ol>
<p >That leaves two questions: why are we iterating using a <code>char*</code> and what does <code>*(void**)p</code> do?</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Stack alignment and &lt;tt&gt;char*&lt;/tt&gt;</h2>
<p >The reason why we are using a <code>char*</code> to iterate over the stack is because it allows us to access each byte on the stack. This is simply an (inefficient) approach to not having to deal with stack alignment across different platforms and/or compilers.</p>
<p >An obvious optimization would be to assume proper stack alignment of pointers and, starting from <code>stack_sp</code>, work out way forward in 4- (for 32 bit systems) or 8-byte (for 64 bit systems) steps instead of the 1-byte steps afforded by <code>char*</code>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Deciphering &lt;tt&gt;*(void**)p&lt;/tt&gt;</h2>
<p >It's just confusing to read, and we can make it easier by introducing a <code>typedef</code>. Let's define a pointer to a memory location like so:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">void</span>* MemPtr</div>
</div><!-- fragment --><p >We can then rewrite <code>*(void**)p</code> as</p>
<div class="fragment"><div class="line">`*(MemPtr*)p`</div>
</div><!-- fragment --><p >making the syntax much less confusing. In detail, <code>p</code> is of type <code>char*</code>, so <code>(MemPtr*)p</code> is just a cast of the <code>char</code> pointer to be a pointer to a <code>MemPtr</code> type. The leftmost asterisk then dereferences to the content of the memory address pointed to by the <code>MemPtr*</code>, which is the content we want to check for references (i.e. pointers) to known memory locations.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Scanning the heap</h1>
<p >Compared to scanning the stack, scanning the heap is trivial: we just iterate over all known allocations and check if they contain a pointer to another (known) allocation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> bgc_mark_roots(GarbageCollector* gc)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; gc-&gt;allocs-&gt;capacity; ++i) {</div>
<div class="line">        Allocation* chunk = gc-&gt;allocs-&gt;allocs[i];</div>
<div class="line">        <span class="keywordflow">while</span> (chunk) {</div>
<div class="line">            <span class="keywordflow">if</span> (chunk-&gt;tag &amp; BGC_TAG_ROOT) {</div>
<div class="line">                bgc_mark_alloc(gc, chunk-&gt;ptr);</div>
<div class="line">            }</div>
<div class="line">            chunk = chunk-&gt;next;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Implementing &lt;tt&gt;gc_mark_alloc()&lt;/tt&gt;</h1>
<p >Taking a closer look at <code>gc_mark_alloc()</code> reveals that it is really only a loop that iterates over the memory content of an allocation, attempting to find any pointers located within:</p>
<p >```c void bgc_mark_alloc(GarbageCollector* gc, void* ptr) { Allocation* alloc = bgc_allocation_map_get(gc-&gt;allocs, ptr); if (alloc &amp;&amp; !(alloc-&gt;tag &amp; BGC_TAG_MARK)) { alloc-&gt;tag |= BGC_TAG_MARK; for (char* p = (char*) alloc-&gt;ptr; p &lt;= (char*) alloc-&gt;ptr + alloc-&gt;size - BGC_PTRSIZE; ++p) { bgc_mark_alloc(gc, *(void**)p); } } } </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
